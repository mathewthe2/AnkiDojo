import { fetchAnki } from "../anki";
import NoteAddInterface from "@/interfaces/card_builder/NoteAddInterface";
import ExpressionTerm from "@/interfaces/card_builder/ExpressionTerm";
import RawNoteAddInterface from "@/interfaces/card_builder/RawNoteAddInterface";
import { FieldValueType } from "../anki";

const ADD_NOTE_OPTIONS = {
  allowDuplicate: true,
};

export const hasMecabSupport = async () => {
  const result = await fetchAnki("mecab_support");
  if (result["has_mecab"]) {
    return result["has_mecab"];
  } else {
    return false;
  }
};

export const addNotesToAnki = async (notesToAdd: NoteAddInterface[]) => {
  const body = {
    notes: notesToAdd.map((note) => {
      return {
        ...note,
        fields: Object.fromEntries(note.fields),
        options: ADD_NOTE_OPTIONS,
      };
    }),
  };
  const response = await fetch(`${process.env.ANKI_HOST}/api/notes`, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });
  try {
    const content = await response.json();
    return content;
  } catch (e) {
    console.warn(e);
  }
};

export const jsonNotesToExpressionTerms = (jsonNotes: any) => {
  const expressionTerms: ExpressionTerm[] = jsonNotes.map((jsonNote: any) => {
    return {
      userExpression: jsonNote[FieldValueType.Expression] || "",
      definition: {
        expression: jsonNote[FieldValueType.Expression] || "",
        reading: jsonNote[FieldValueType.Reading] || "",
        glossary:
          jsonNote[FieldValueType.Glossary] ||
          jsonNote[FieldValueType.GlossaryBrief] ||
          "",
        sentences: jsonNote[FieldValueType.Sentence]
          ? [jsonNote[FieldValueType.Sentence]]
          : [],
        sentence_translations: jsonNote[FieldValueType.SentenceTranslation]
          ? [jsonNote[FieldValueType.SentenceTranslation]]
          : [],
        audio_urls: jsonNote[FieldValueType.Audio]
          ? [jsonNote[FieldValueType.Audio]]
          : [],
        tags: jsonNote["tags"] || [],
      },
    } as ExpressionTerm;
  });
  return expressionTerms;
};

export const rawNotesToExpressionTerms = (rawNotes: RawNoteAddInterface[]) => {
  const expressionTerms: ExpressionTerm[] = rawNotes.map(
    (rawTerm: RawNoteAddInterface) => {
      return {
        userExpression: rawTerm.fields.get(FieldValueType.Expression) || "",
        definition: {
          expression: rawTerm.fields.get(FieldValueType.Expression),
          reading: rawTerm.fields.get(FieldValueType.Reading),
          glossary: rawTerm.fields.get(FieldValueType.Glossary),
          sentences: rawTerm.fields.get(FieldValueType.Sentence)
            ? [rawTerm.fields.get(FieldValueType.Sentence)]
            : [],
          sentence_translations: rawTerm.fields.get(
            FieldValueType.SentenceTranslation
          )
            ? [rawTerm.fields.get(FieldValueType.SentenceTranslation)]
            : [],
          audio_urls: rawTerm.audio?.[0]?.url
            ? [
                {
                  name: rawTerm.audio?.[0]?.filename,
                  url: rawTerm.audio?.[0]?.url,
                },
              ]
            : [],
          // no sentence translation for now
          // pitch is generated by Anki Dojo
        },
        tags: rawTerm.fields.get("tags") || [],
        // TODO: add options
      } as ExpressionTerm;
    }
  );
  return expressionTerms;
};
