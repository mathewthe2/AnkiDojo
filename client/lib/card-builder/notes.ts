import { fetchAnki } from "../anki";
import NoteAddInterface from "@/interfaces/card_builder/NoteAddInterface";
import ExpressionTerm from "@/interfaces/card_builder/ExpressionTerm";
import RawNoteAddInterface from "@/interfaces/card_builder/RawNoteAddInterface";
import { FieldValueType } from "../anki";
import NoteResult, { AddedNote, SkippedNote } from "@/interfaces/card_builder/NoteResultInterface";

export const hasMecabSupport = async () => {
  const result = await fetchAnki("mecab_support");
  if (result["has_mecab"]) {
    return result["has_mecab"];
  } else {
    return false;
  }
};

export const addNotesToAnki = async (notesToAdd: NoteAddInterface[]) => {
  const body = {
    notes: notesToAdd.map((note) => {
      return {
        ...note,
        fields: Object.fromEntries(note.fields),
        options: {},
      };
    }),
  };
  const response = await fetch(`${process.env.ANKI_HOST}/api/notes`, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });
  try {
    const content = await response.json();
    const addedNotes: AddedNote[] = content['addedNotes'].map(
      (addedNote: any) => {
        return {
          ...addedNote,
          fields: new Map(Object.entries(addedNote.fields)),
        };
      });
    const skippedNotes: SkippedNote[] = content['skippedNotes'].map(
      (skippedNotes: any) => {
        return {
          fields: new Map(Object.entries(skippedNotes.fields)),
        };
      });
    const noteResult: NoteResult = {
      addedNotes: addedNotes,
      skippedNotes: skippedNotes
    }
    return noteResult;
  } catch (e) {
    console.warn(e);
  }
};

export const jsonNotesToExpressionTerms = (jsonNotes: any) => {
  const expressionTerms: ExpressionTerm[] = jsonNotes.map((jsonNote: any) => {
    const glossary = jsonNote[FieldValueType.Glossary] ||
      jsonNote[FieldValueType.GlossaryBrief] || undefined;
    return {
      userExpression: jsonNote[FieldValueType.Expression] || "",
      definition: {
        expression: jsonNote[FieldValueType.Expression] || "",
        reading: jsonNote[FieldValueType.Reading] || "",
        selectedGlossary: glossary || '',
        glossary: glossary ? [glossary] : [],
        sentences: jsonNote[FieldValueType.Sentence]
          ? [jsonNote[FieldValueType.Sentence]]
          : [],
        sentence_translations: jsonNote[FieldValueType.SentenceTranslation]
          ? [jsonNote[FieldValueType.SentenceTranslation]]
          : [],
        audio_urls: jsonNote[FieldValueType.Audio]
          ? [jsonNote[FieldValueType.Audio]]
          : [],
        tags: jsonNote["tags"] || [],
      },
    } as ExpressionTerm;
  });
  return expressionTerms;
};

export const rawNotesToExpressionTerms = (rawNotes: RawNoteAddInterface[]) => {
  const expressionTerms: ExpressionTerm[] = rawNotes.map(
    (rawTerm: RawNoteAddInterface) => {
      return {
        userExpression: rawTerm.fields.get(FieldValueType.Expression) || "",
        definition: {
          expression: rawTerm.fields.get(FieldValueType.Expression),
          reading: rawTerm.fields.get(FieldValueType.Reading),
          glossary: rawTerm.fields.get(FieldValueType.Glossary),
          sentences: rawTerm.fields.get(FieldValueType.Sentence)
            ? [rawTerm.fields.get(FieldValueType.Sentence)]
            : [],
          sentence_translations: rawTerm.fields.get(
            FieldValueType.SentenceTranslation
          )
            ? [rawTerm.fields.get(FieldValueType.SentenceTranslation)]
            : [],
          audio_urls: rawTerm.audio?.[0]?.url
            ? [
              {
                name: rawTerm.audio?.[0]?.filename,
                url: rawTerm.audio?.[0]?.url,
              },
            ]
            : [],
          // no sentence translation for now
          // pitch is generated by Anki Dojo
        },
        tags: rawTerm.fields.get("tags") || [],
        // TODO: add options
      } as ExpressionTerm;
    }
  );
  return expressionTerms;
};
